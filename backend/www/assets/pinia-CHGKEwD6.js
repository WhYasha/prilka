import{U as K,aJ as nt,af as V,a0 as B,a6 as q,o as z,ab as x,a9 as O,b3 as st,b2 as G,W as ot,aw as ct,aH as rt,aj as ut,b4 as at,bi as it}from"./runtime-core.esm-bundler-DriOm3-t.js";let H;const A=t=>H=t,yt=()=>B()&&q(L)||H,L=Symbol();function I(t){return t&&typeof t=="object"&&Object.prototype.toString.call(t)==="[object Object]"&&typeof t.toJSON!="function"}var p;(function(t){t.direct="direct",t.patchObject="patch object",t.patchFunction="patch function"})(p||(p={}));function _t(){const t=K(!0),s=t.run(()=>nt({}));let n=[],e=[];const o=V({install(u){A(o),o._a=u,u.provide(L,o),u.config.globalProperties.$pinia=o,e.forEach(a=>n.push(a)),e=[]},use(u){return this._a?n.push(u):e.push(u),this},_p:n,_a:null,_e:t,_s:new Map,state:s});return o}function jt(t){t._e.stop(),t._s.clear(),t._p.splice(0),t.state.value={},t._a=null}function dt(t,s){return()=>{}}const Q=()=>{};function U(t,s,n,e=Q){t.add(s);const o=()=>{t.delete(s)&&e()};return!n&&ot()&&ct(o),o}function w(t,...s){t.forEach(n=>{n(...s)})}const ft=t=>t(),J=Symbol(),$=Symbol();function W(t,s){t instanceof Map&&s instanceof Map?s.forEach((n,e)=>t.set(e,n)):t instanceof Set&&s instanceof Set&&s.forEach(t.add,t);for(const n in s){if(!s.hasOwnProperty(n))continue;const e=s[n],o=t[n];I(o)&&I(e)&&t.hasOwnProperty(n)&&!x(e)&&!O(e)?t[n]=W(o,e):t[n]=e}return t}const X=Symbol();function wt(t){return Object.defineProperty(t,X,{})}function lt(t){return!I(t)||!Object.prototype.hasOwnProperty.call(t,X)}const{assign:h}=Object;function ht(t){return!!(x(t)&&t.effect)}function bt(t,s,n,e){const{state:o,actions:u,getters:a}=s,P=n.state.value[t];let S;function b(){P||(n.state.value[t]=o?o():{});const v=at(n.state.value[t]);return h(v,u,Object.keys(a||{}).reduce((m,y)=>(m[y]=V(z(()=>{A(n);const _=n._s.get(t);return a[y].call(_,_)})),m),{}))}return S=Y(t,b,s,n,e,!0),S}function Y(t,s,n={},e,o,u){let a;const P=h({actions:{}},n),S={deep:!0};let b,v,m=new Set,y=new Set,_;const j=e.state.value[t];!u&&!j&&(e.state.value[t]={});let N;function D(r){let c;b=v=!1,typeof r=="function"?(r(e.state.value[t]),c={type:p.patchFunction,storeId:t,events:_}):(W(e.state.value[t],r),c={type:p.patchObject,payload:r,storeId:t,events:_});const i=N=Symbol();ut().then(()=>{N===i&&(b=!0)}),v=!0,w(m,c,e.state.value[t])}const T=u?function(){const{state:c}=n,i=c?c():{};this.$patch(d=>{h(d,i)})}:Q;function k(){a.stop(),m.clear(),y.clear(),e._s.delete(t)}const F=(r,c="")=>{if(J in r)return r[$]=c,r;const i=function(){A(e);const d=Array.from(arguments),C=new Set,E=new Set;function tt(f){C.add(f)}function et(f){E.add(f)}w(y,{args:d,name:i[$],store:l,after:tt,onError:et});let R;try{R=r.apply(this&&this.$id===t?this:l,d)}catch(f){throw w(E,f),f}return R instanceof Promise?R.then(f=>(w(C,f),f)).catch(f=>(w(E,f),Promise.reject(f))):(w(C,R),R)};return i[J]=!0,i[$]=c,i},M={_p:e,$id:t,$onAction:U.bind(null,y),$patch:D,$reset:T,$subscribe(r,c={}){const i=U(m,r,c.detached,()=>d()),d=a.run(()=>it(()=>e.state.value[t],C=>{(c.flush==="sync"?v:b)&&r({storeId:t,type:p.direct,events:_},C)},h({},S,c)));return i},$dispose:k},l=rt(M);e._s.set(t,l);const g=(e._a&&e._a.runWithContext||ft)(()=>e._e.run(()=>(a=K()).run(()=>s({action:F}))));for(const r in g){const c=g[r];if(x(c)&&!ht(c)||O(c))u||(j&&lt(c)&&(x(c)?c.value=j[r]:W(c,j[r])),e.state.value[t][r]=c);else if(typeof c=="function"){const i=F(c,r);g[r]=i,P.actions[r]=c}}return h(l,g),h(G(l),g),Object.defineProperty(l,"$state",{get:()=>e.state.value[t],set:r=>{D(c=>{h(c,r)})}}),e._p.forEach(r=>{h(l,a.run(()=>r({store:l,app:e._a,pinia:e,options:P})))}),j&&u&&n.hydrate&&n.hydrate(l.$state,j),b=!0,v=!0,l}function Pt(t,s,n){let e;const o=typeof s=="function";e=o?n:s;function u(a,P){const S=B();return a=a||(S?q(L,null):null),a&&A(a),a=H,a._s.has(t)||(o?Y(t,s,e,a):bt(t,e,a)),a._s.get(t)}return u.$id=t,u}let Z="Store";function gt(t){Z=t}function Ct(...t){return t.reduce((s,n)=>(s[n.$id+Z]=function(){return n(this.$pinia)},s),{})}function St(t,s){return Array.isArray(s)?s.reduce((n,e)=>(n[e]=function(){return t(this.$pinia)[e]},n),{}):Object.keys(s).reduce((n,e)=>(n[e]=function(){const o=t(this.$pinia),u=s[e];return typeof u=="function"?u.call(this,o):o[u]},n),{})}const Rt=St;function pt(t,s){return Array.isArray(s)?s.reduce((n,e)=>(n[e]=function(...o){return t(this.$pinia)[e](...o)},n),{}):Object.keys(s).reduce((n,e)=>(n[e]=function(...o){return t(this.$pinia)[s[e]](...o)},n),{})}function xt(t,s){return Array.isArray(s)?s.reduce((n,e)=>(n[e]={get(){return t(this.$pinia)[e]},set(o){return t(this.$pinia)[e]=o}},n),{}):Object.keys(s).reduce((n,e)=>(n[e]={get(){return t(this.$pinia)[s[e]]},set(o){return t(this.$pinia)[s[e]]=o}},n),{})}function At(t){const s=G(t),n={};for(const e in s){const o=s[e];o.effect?n[e]=z({get:()=>t[e],set(u){t[e]=u}}):(x(o)||O(o))&&(n[e]=st(t,e))}return n}export{p as MutationType,dt as acceptHMRUpdate,_t as createPinia,Pt as defineStore,jt as disposePinia,yt as getActivePinia,pt as mapActions,Rt as mapGetters,St as mapState,Ct as mapStores,xt as mapWritableState,A as setActivePinia,gt as setMapStoreSuffix,lt as shouldHydrate,wt as skipHydrate,At as storeToRefs};
